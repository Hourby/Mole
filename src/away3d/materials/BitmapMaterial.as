package away3d.materials{	import away3d.arcane;	import away3d.cameras.Camera3D;	import flash.display.BitmapData;	import flash.display3D.Context3D;	import flash.geom.ColorTransform;	import flash.geom.Matrix;	use namespace arcane;	/**	 * BitmapMaterial is a material that uses a BitmapData texture as the surface's diffuse colour.	 */	public class BitmapMaterial extends DefaultMaterialBase	{		private var _transparent : Boolean;		private var _offsetU : Number = 0;		private var _offsetV : Number = 0;		private var _scaleU : Number = 1;		private var _scaleV : Number = 1;		private var _uvRotation : Number = 0;		private var _uvTransformDirty : Boolean;		/**		 * Creates a new BitmapMaterial.		 * @param bitmapData The BitmapData object to use as the texture.		 * @param smooth Indicates whether or not the texture should use smoothing.		 * @param repeat Indicates whether or not the texture should be tiled.		 * @param mipmap Indicates whether or not the texture should use mipmapping.		 */		public function BitmapMaterial(bitmapData : BitmapData = null, smooth : Boolean = true, repeat : Boolean = false, mipmap : Boolean = true)		{			super();			this.bitmapData = bitmapData;			this.smooth = smooth;			this.repeat = repeat;			this.mipmap = mipmap;		}		public function get offsetU() : Number		{			return _offsetU;		}		public function set offsetU(value : Number) : void		{			if (value == _offsetU) return;			_offsetU = value;			_uvTransformDirty = true;		}		public function get offsetV() : Number		{			return _offsetV;		}		public function set offsetV(value : Number) : void		{			if (value == _offsetV) return;			_offsetV = value;			_uvTransformDirty = true;		}		public function get scaleU() : Number		{			return _scaleU;		}		public function set scaleU(value : Number) : void		{			if (value == _scaleU) return;			_scaleU = value;			_uvTransformDirty = true;		}		public function get scaleV() : Number		{			return _scaleV;		}		public function set scaleV(value : Number) : void		{			if (value == _scaleV) return;			_scaleV = value;			_uvTransformDirty = true;		}		public function get uvRotation() : Number		{			return _uvRotation;		}		public function set uvRotation(value : Number) : void		{			if (value == _uvRotation) return;			_uvRotation = value;			_uvTransformDirty = true;		}		/**		 * The alpha of the surface.		 */		public function get alpha() : Number		{			return _screenPass.colorTransform? _screenPass.colorTransform.alphaMultiplier : 1;		}		public function set alpha(value : Number) : void		{			if (value > 1) value = 1;			else if (value < 0) value = 0;			colorTransform ||= new ColorTransform();			colorTransform.alphaMultiplier = value;		}		arcane override function activatePass(index : uint, context : Context3D, contextIndex : uint, camera : Camera3D) : void		{			if (_uvTransformDirty) updateUVTransform();			super.arcane::activatePass(index, context, contextIndex, camera);		}		private function updateUVTransform() : void		{			var transform : Matrix = _screenPass.uvTransform ||= new Matrix();			transform.identity();			if (_uvRotation != 0) transform.rotate(_uvRotation);			if (_scaleU != 1 || _scaleV != 1) transform.scale(_scaleU, _scaleV);			transform.translate(_offsetU, _offsetV);			_uvTransformDirty = false;		}		/**		 * The BitmapData object to use as the texture.		 */		public function get bitmapData() : BitmapData		{			return _screenPass.diffuseMethod.bitmapData;		}		public function set bitmapData(value : BitmapData) : void		{			if(isBitmapDataValid(value))				_screenPass.diffuseMethod.bitmapData = value;			else				throw new Error("Invalid bitmapData! Must be power of 2 and not exceeding 2048");		}		/**		 * Triggers an update of the texture, to be used when the contents of the BitmapData has changed.		 */		public function updateTexture() : void		{			_screenPass.diffuseMethod.invalidateBitmapData();		}		override public function get requiresBlending() : Boolean		{			return super.requiresBlending || _transparent;		}		/**		 * Indicate whether or not the BitmapData contains transparency.		 */		public function get transparent() : Boolean		{			return _transparent;		}		public function set transparent(value : Boolean) : void		{			_transparent = value;		}		/**		 * @inheritDoc		 */		override public function dispose(deep : Boolean) : void		{			if (deep)				_screenPass.dispose(deep);			super.dispose(deep);		}	}}